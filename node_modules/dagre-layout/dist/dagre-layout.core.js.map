{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///./lib/util.js","webpack:///external \"graphlibrary\"","webpack:///./lib/rank/util.js","webpack:///./lib/rank/feasible-tree.js","webpack:///./lib/position/bk.js","webpack:///./lib/position/index.js","webpack:///./lib/order/add-subgraph-constraints.js","webpack:///./lib/order/build-layer-graph.js","webpack:///./lib/order/sort.js","webpack:///./lib/order/resolve-conflicts.js","webpack:///./lib/order/barycenter.js","webpack:///./lib/order/sort-subgraph.js","webpack:///./lib/order/cross-count.js","webpack:///./lib/order/init-order.js","webpack:///./lib/order/index.js","webpack:///./lib/coordinate-system.js","webpack:///./lib/add-border-segments.js","webpack:///./lib/nesting-graph.js","webpack:///./lib/parent-dummy-chains.js","webpack:///./lib/rank/network-simplex.js","webpack:///./lib/rank/index.js","webpack:///./lib/normalize.js","webpack:///./lib/data/list.js","webpack:///./lib/greedy-fas.js","webpack:///./lib/acyclic.js","webpack:///./lib/layout.js","webpack:///./index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","require","addDummyNode","simplify","asNonCompoundGraph","successorWeights","predecessorWeights","intersectRect","buildLayerMatrix","normalizeRanks","removeEmptyRanks","addBorderNode","maxRank","partition","time","notime","_lodash","_graphlibrary","g","type","attrs","v","_lodash2","default","uniqueId","hasNode","dummy","setNode","simplified","Graph","setGraph","graph","forEach","nodes","node","edges","e","simpleLabel","edge","weight","minlen","label","setEdge","Math","max","multigraph","isMultigraph","children","length","weightMap","map","sucs","outEdges","zipObject","preds","inEdges","rect","point","x","y","dx","dy","width","h","height","Error","sx","sy","abs","layering","range","rank","isUndefined","order","min","has","offset","layers","push","delta","nodeRankFactor","vs","prefix","arguments","collection","fn","result","lhs","rhs","start","now","console","log","longestPath","slack","visited","sources","dfs","_util","tightTree","t","nodeEdges","edgeV","nodeCount","findMinSlackEdge","minBy","shiftRanks","directed","size","positionX","findType1Conflicts","conflicts","reduce","prevLayer","layer","k0","scanPos","prevLayerLength","lastNode","last","find","predecessors","u","findOtherInnerSegmentNode","k1","slice","scanNode","uLabel","uPos","addConflict","findType2Conflicts","scan","south","southPos","southEnd","prevNorthBorder","nextNorthBorder","uNode","north","prevNorthPos","nextNorthPos","southLookahead","tmp","conflictsV","hasConflict","verticalAlignment","neighborFn","root","align","pos","prevIdx","ws","mp","sortBy","floor","il","ceil","horizontalCompaction","reverseSep","xs","blockG","blockGraph","graphLabel","sepFn","nodeSep","edgeSep","vLabel","wLabel","sum","labelpos","toLowerCase","sep","nodesep","edgesep","vRoot","uRoot","prevMax","buildBlockGraph","pass1","borderType","pass2","Number","POSITIVE_INFINITY","findSmallestWidthAlignment","xss","values","toPairs","pair","maxBy","alignCoordinates","alignTo","alignToVals","alignToMin","alignToMax","vert","horiz","alignment","xsVals","mapValues","balance","ul","ignore","_util2","merge","adjustedLayering","reverse","inner","bind","successors","smallestWidth","_bk","rankSep","ranksep","prevY","maxHeight","positionY","cg","prev","rootPrev","child","parent","prevChild","relationship","createRootNode","compound","setDefaultNodeLabel","minRank","setParent","borderLeft","borderRight","consumeUnsortable","unsortable","index","pop","entries","biasRight","bias","parts","entry","sortable","vsIndex","sort","entryV","entryW","barycenter","flatten","mappedEntries","indegree","in","out","sourceSet","handleIn","vEntry","uEntry","target","source","merged","concat","handleOut","wEntry","chain","filter","pick","doResolveConflicts","movable","inV","acc","nodeU","sortSubgraph","bl","undefined","br","subgraphs","barycenters","_barycenter2","subgraphResult","other","_resolveConflicts2","expandSubgraphs","_sort2","blPred","brPred","twoLayerCrossCount","northLayer","southLayer","southEntries","firstIndex","treeSize","tree","Array","cc","weightSum","simpleNodes","orderedVs","buildLayerGraphs","ranks","_buildLayerGraph2","sweepLayerGraphs","layerGraphs","lg","sorted","_sortSubgraph2","_addSubgraphConstraints2","assignOrder","downLayerGraphs","upLayerGraphs","_initOrder2","bestCC","best","lastBest","_crossCount2","cloneDeep","swapWidthHeight","swapWidthHeightOne","reverseYOne","swapXYOne","adjust","rankDir","rankdir","undo","points","reverseY","swapXY","prop","sg","sgNode","curr","run","depths","depth","treeDepths","nestingRoot","sumWeights","top","bottom","borderTop","borderBottom","childNode","childTop","childBottom","thisWeight","nestingEdge","cleanup","removeNode","removeEdge","postorderNums","lim","low","postorder","dummyChains","edgeObj","pathData","vPath","wPath","lca","path","findPath","pathIdx","pathV","ascending","preorder","networkSimplex","_feasibleTree2","initLowLimValues","initCutValues","leaveEdge","exchangeEdges","enterEdge","cutvalue","calcCutValue","assignCutValue","childIsTail","graphEdge","cutValue","isOutEdge","pointsToHead","otherWeight","hasEdge","otherCutValue","dfsAssignLowLim","nextLim","neighbors","tailLabel","flip","candidates","isDescendant","f","flipped","updateRanks","rootLabel","longestPathRanker","networkSimplexRanker","_networkSimplex2","ranker","tightTreeRanker","vRank","wRank","edgeLabel","labelRank","normalizeEdge","origLabel","List","sentinel","_next","_prev","this","_sentinel","unlink","filterOutLinks","k","dequeue","enqueue","toString","strs","JSON","stringify","join","DEFAULT_WEIGHT_FN","constant","buckets","zeroIdx","collectPredecessors","results","assignBucket","weightFn","state","fasGraph","maxIn","maxOut","prevWeight","edgeWeight","_list2","buildState","sinks","doGreedyFAS","fas","acyclicer","_greedyFas2","stack","dfsFAS","forwardName","reversed","graphNumAttrs","graphDefaults","graphAttrs","nodeNumAttrs","nodeDefaults","edgeNumAttrs","edgeDefaults","labeloffset","edgeAttrs","selectNumberAttrs","obj","canonicalize","newAttrs","opts","debugTiming","layoutGraph","inputGraph","defaults","buildLayoutGraph","makeSpaceForEdgeLabels","selfEdges","removeSelfEdges","_acyclic2","_nestingGraph2","_rank2","injectEdgeLabelProxies","assignRankMinMax","removeEdgeLabelProxies","_normalize2","_parentDummyChains2","_addBorderSegments2","_order2","orderShift","selfEdge","insertSelfEdges","_coordinateSystem2","_position2","selfNode","positionSelfEdges","b","removeBorderNodes","fixupEdgeLabelCoords","minX","maxX","minY","maxY","marginX","marginx","marginY","marginy","getExtremes","translateGraph","nodeV","nodeW","p1","p2","unshift","assignNodeIntersects","reversePointsForReversedEdges","runLayout","inputLabel","layoutLabel","updateInputGraph","_layout","layout"],"mappings":"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","file":"dagre-layout.core.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n","module.exports = require(\"lodash\");","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nexport function addDummyNode (g, type, attrs, name) {\n  let v\n  do {\n    v = _.uniqueId(name)\n  } while (g.hasNode(v))\n\n  attrs.dummy = type\n  g.setNode(v, attrs)\n  return v\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nexport function simplify (g) {\n  const simplified = new Graph().setGraph(g.graph())\n  _.forEach(g.nodes(), function (v) { simplified.setNode(v, g.node(v)) })\n  _.forEach(g.edges(), function (e) {\n    const simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 }\n    const label = g.edge(e)\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    })\n  })\n  return simplified\n}\n\nexport function asNonCompoundGraph (g) {\n  const simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph())\n  _.forEach(g.nodes(), function (v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v))\n    }\n  })\n  _.forEach(g.edges(), function (e) {\n    simplified.setEdge(e, g.edge(e))\n  })\n  return simplified\n}\n\nexport function successorWeights (g) {\n  const weightMap = _.map(g.nodes(), function (v) {\n    const sucs = {}\n    _.forEach(g.outEdges(v), function (e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight\n    })\n    return sucs\n  })\n  return _.zipObject(g.nodes(), weightMap)\n}\n\nexport function predecessorWeights (g) {\n  const weightMap = _.map(g.nodes(), function (v) {\n    const preds = {}\n    _.forEach(g.inEdges(v), function (e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight\n    })\n    return preds\n  })\n  return _.zipObject(g.nodes(), weightMap)\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nexport function intersectRect (rect, point) {\n  const x = rect.x\n  const y = rect.y\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  const dx = point.x - x\n  const dy = point.y - y\n  let w = rect.width / 2\n  let h = rect.height / 2\n\n  if (!dx && !dy) {\n    throw new Error('Not possible to find intersection inside of the rectangle')\n  }\n\n  let sx\n  let sy\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h\n    }\n    sx = h * dx / dy\n    sy = h\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w\n    }\n    sx = w\n    sy = w * dy / dx\n  }\n\n  return { x: x + sx, y: y + sy }\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nexport function buildLayerMatrix (g) {\n  const layering = _.map(_.range(maxRank(g) + 1), function () { return [] })\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    const rank = node.rank\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v\n    }\n  })\n  return layering\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nexport function normalizeRanks (g) {\n  const min = _.min(_.map(g.nodes(), function (v) { return g.node(v).rank }))\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (_.has(node, 'rank')) {\n      node.rank -= min\n    }\n  })\n}\n\nexport function removeEmptyRanks (g) {\n  // Ranks may not start at 0, so we need to offset them\n  const offset = _.min(_.map(g.nodes(), function (v) { return g.node(v).rank }))\n\n  const layers = []\n  _.forEach(g.nodes(), function (v) {\n    const rank = g.node(v).rank - offset\n    if (!layers[rank]) {\n      layers[rank] = []\n    }\n    layers[rank].push(v)\n  })\n\n  let delta = 0\n  const nodeRankFactor = g.graph().nodeRankFactor\n  _.forEach(layers, function (vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta\n    } else if (delta) {\n      _.forEach(vs, function (v) { g.node(v).rank += delta })\n    }\n  })\n}\n\nexport function addBorderNode (g, prefix, rank, order) {\n  const node = {\n    width: 0,\n    height: 0\n  }\n  if (arguments.length >= 4) {\n    node.rank = rank\n    node.order = order\n  }\n  return addDummyNode(g, 'border', node, prefix)\n}\n\nexport function maxRank (g) {\n  return _.max(_.map(g.nodes(), function (v) {\n    const rank = g.node(v).rank\n    if (!_.isUndefined(rank)) {\n      return rank\n    }\n  }))\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nexport function partition (collection, fn) {\n  const result = { lhs: [], rhs: [] }\n  _.forEach(collection, function (value) {\n    if (fn(value)) {\n      result.lhs.push(value)\n    } else {\n      result.rhs.push(value)\n    }\n  })\n  return result\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nexport function time (name, fn) {\n  const start = _.now()\n  try {\n    return fn()\n  } finally {\n    console.log(name + ' time: ' + (_.now() - start) + 'ms')\n  }\n}\n\nexport function notime (name, fn) {\n  return fn()\n}\n\nexport default {\n  addDummyNode,\n  simplify,\n  asNonCompoundGraph,\n  successorWeights,\n  predecessorWeights,\n  intersectRect,\n  buildLayerMatrix,\n  normalizeRanks,\n  removeEmptyRanks,\n  addBorderNode,\n  maxRank,\n  partition,\n  time,\n  notime\n}\n","module.exports = require(\"graphlibrary\");","import _ from 'lodash'\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nexport function longestPath (g) {\n  const visited = {}\n\n  function dfs (v) {\n    const label = g.node(v)\n    if (_.has(visited, v)) {\n      return label.rank\n    }\n    visited[v] = true\n\n    const rank = _.min(_.map(g.outEdges(v), function (e) {\n      return dfs(e.w) - g.edge(e).minlen\n    })) || 0\n\n    return (label.rank = rank)\n  }\n\n  _.forEach(g.sources(), dfs)\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nexport function slack (g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen\n}\n\nexport default {\n  longestPath: longestPath,\n  slack: slack\n}\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport { slack } from './util'\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nfunction feasibleTree (g) {\n  const t = new Graph({ directed: false })\n\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0]\n  const size = g.nodeCount()\n  t.setNode(start, {})\n\n  let edge\n  let delta\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g)\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge)\n    shiftRanks(t, g, delta)\n  }\n\n  return t\n}\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nfunction tightTree (t, g) {\n  function dfs (v) {\n    _.forEach(g.nodeEdges(v), function (e) {\n      const edgeV = e.v\n      const w = (v === edgeV) ? e.w : edgeV\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {})\n        t.setEdge(v, w, {})\n        dfs(w)\n      }\n    })\n  }\n\n  _.forEach(t.nodes(), dfs)\n  return t.nodeCount()\n}\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nfunction findMinSlackEdge (t, g) {\n  return _.minBy(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e)\n    }\n  })\n}\n\nfunction shiftRanks (t, g, delta) {\n  _.forEach(t.nodes(), function (v) {\n    g.node(v).rank += delta\n  })\n}\n\nexport default feasibleTree\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport util from '../util'\n\n/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts (g, layering) {\n  const conflicts = {}\n\n  function visitLayer (prevLayer, layer) {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    let k0 = 0\n    // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    let scanPos = 0\n    const prevLayerLength = prevLayer.length\n    const lastNode = _.last(layer)\n\n    _.forEach(layer, function (v, i) {\n      const w = findOtherInnerSegmentNode(g, v)\n      const k1 = w ? g.node(w).order : prevLayerLength\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i + 1), function (scanNode) {\n          _.forEach(g.predecessors(scanNode), function (u) {\n            const uLabel = g.node(u)\n            const uPos = uLabel.order\n            if ((uPos < k0 || k1 < uPos) &&\n              !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode)\n            }\n          })\n        })\n        scanPos = i + 1\n        k0 = k1\n      }\n    })\n\n    return layer\n  }\n\n  _.reduce(layering, visitLayer)\n  return conflicts\n}\n\nfunction findType2Conflicts (g, layering) {\n  const conflicts = {}\n\n  function scan (south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    let v\n    _.forEach(_.range(southPos, southEnd), function (i) {\n      v = south[i]\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function (u) {\n          const uNode = g.node(u)\n          if (uNode.dummy &&\n            (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v)\n          }\n        })\n      }\n    })\n  }\n\n  function visitLayer (north, south) {\n    let prevNorthPos = -1\n    let nextNorthPos\n    let southPos = 0\n\n    _.forEach(south, function (v, southLookahead) {\n      if (g.node(v).dummy === 'border') {\n        const predecessors = g.predecessors(v)\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos)\n          southPos = southLookahead\n          prevNorthPos = nextNorthPos\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length)\n    })\n\n    return south\n  }\n\n  _.reduce(layering, visitLayer)\n  return conflicts\n}\n\nfunction findOtherInnerSegmentNode (g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function (u) {\n      return g.node(u).dummy\n    })\n  }\n}\n\nfunction addConflict (conflicts, v, w) {\n  if (v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n\n  let conflictsV = conflicts[v]\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {}\n  }\n  conflictsV[w] = true\n}\n\nfunction hasConflict (conflicts, v, w) {\n  if (v > w) {\n    const tmp = v\n    v = w\n    w = tmp\n  }\n  return _.has(conflicts[v], w)\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment (g, layering, conflicts, neighborFn) {\n  const root = {}\n  const align = {}\n  const pos = {}\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, order) {\n      root[v] = v\n      align[v] = v\n      pos[v] = order\n    })\n  })\n\n  _.forEach(layering, function (layer) {\n    let prevIdx = -1\n    _.forEach(layer, function (v) {\n      let ws = neighborFn(v)\n      if (ws.length) {\n        ws = _.sortBy(ws, function (w) { return pos[w] })\n        const mp = (ws.length - 1) / 2\n        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          const w = ws[i]\n          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {\n            align[w] = v\n            align[v] = root[v] = root[w]\n            prevIdx = pos[w]\n          }\n        }\n      }\n    })\n  })\n\n  return { root: root, align: align }\n}\n\nfunction horizontalCompaction (g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  const xs = {}\n  const blockG = buildBlockGraph(g, layering, root, reverseSep)\n\n  // First pass, assign smallest coordinates via DFS\n  const visited = {}\n  function pass1 (v) {\n    if (!_.has(visited, v)) {\n      visited[v] = true\n      xs[v] = _.reduce(blockG.inEdges(v), function (max, e) {\n        pass1(e.v)\n        return Math.max(max, xs[e.v] + blockG.edge(e))\n      }, 0)\n    }\n  }\n  _.forEach(blockG.nodes(), pass1)\n\n  const borderType = reverseSep ? 'borderLeft' : 'borderRight'\n  function pass2 (v) {\n    if (visited[v] !== 2) {\n      visited[v]++\n      const node = g.node(v)\n      const min = _.reduce(blockG.outEdges(v), function (min, e) {\n        pass2(e.w)\n        return Math.min(min, xs[e.w] - blockG.edge(e))\n      }, Number.POSITIVE_INFINITY)\n      if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n        xs[v] = Math.max(xs[v], min)\n      }\n    }\n  }\n  _.forEach(blockG.nodes(), pass2)\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function (v) {\n    xs[v] = xs[root[v]]\n  })\n\n  return xs\n}\n\nfunction buildBlockGraph (g, layering, root, reverseSep) {\n  const blockGraph = new Graph()\n  const graphLabel = g.graph()\n  const sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep)\n\n  _.forEach(layering, function (layer) {\n    let u\n    _.forEach(layer, function (v) {\n      const vRoot = root[v]\n      blockGraph.setNode(vRoot)\n      if (u) {\n        const uRoot = root[u]\n        const prevMax = blockGraph.edge(uRoot, vRoot)\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0))\n      }\n      u = v\n    })\n  })\n\n  return blockGraph\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment (g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    const min = (_.minBy(_.toPairs(xs), (pair) => pair[1] - width(g, pair[0]) / 2) || ['k', 0])[1]\n    const max = (_.maxBy(_.toPairs(xs), (pair) => pair[1] + width(g, pair[0]) / 2) || ['k', 0])[1]\n    return max - min\n  })\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates (xss, alignTo) {\n  const alignToVals = _.values(alignTo)\n  const alignToMin = _.min(alignToVals)\n  const alignToMax = _.max(alignToVals)\n\n  _.forEach(['u', 'd'], function (vert) {\n    _.forEach(['l', 'r'], function (horiz) {\n      const alignment = vert + horiz\n      const xs = xss[alignment]\n      if (xs === alignTo) {\n        return\n      }\n      const xsVals = _.values(xs)\n      const delta = horiz === 'l' ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals)\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function (x) { return x + delta })\n      }\n    })\n  })\n}\n\nfunction balance (xss, align) {\n  return _.mapValues(xss.ul, function (ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v]\n    } else {\n      const xs = _.sortBy(_.map(xss, v))\n      return (xs[1] + xs[2]) / 2\n    }\n  })\n}\n\nexport function positionX (g) {\n  const layering = util.buildLayerMatrix(g)\n  const conflicts = _.merge(findType1Conflicts(g, layering), findType2Conflicts(g, layering))\n\n  const xss = {}\n  let adjustedLayering\n  _.forEach(['u', 'd'], function (vert) {\n    adjustedLayering = vert === 'u' ? layering : _.values(layering).reverse()\n    _.forEach(['l', 'r'], function (horiz) {\n      if (horiz === 'r') {\n        adjustedLayering = _.map(adjustedLayering, function (inner) {\n          return _.values(inner).reverse()\n        })\n      }\n\n      const neighborFn = _.bind(vert === 'u' ? g.predecessors : g.successors, g)\n      const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn)\n      let xs = horizontalCompaction(g, adjustedLayering,\n        align.root, align.align,\n        horiz === 'r')\n      if (horiz === 'r') {\n        xs = _.mapValues(xs, function (x) { return -x })\n      }\n      xss[vert + horiz] = xs\n    })\n  })\n\n  const smallestWidth = findSmallestWidthAlignment(g, xss)\n  alignCoordinates(xss, smallestWidth)\n  return balance(xss, g.graph().align)\n}\n\nfunction sep (nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    const vLabel = g.node(v)\n    const wLabel = g.node(w)\n    let sum = 0\n    let delta\n\n    sum += vLabel.width / 2\n    if (_.has(vLabel, 'labelpos')) {\n      switch (vLabel.labelpos.toLowerCase()) {\n        case 'l': delta = -vLabel.width / 2; break\n        case 'r': delta = vLabel.width / 2; break\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta\n    }\n    delta = 0\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2\n\n    sum += wLabel.width / 2\n    if (_.has(wLabel, 'labelpos')) {\n      switch (wLabel.labelpos.toLowerCase()) {\n        case 'l': delta = wLabel.width / 2; break\n        case 'r': delta = -wLabel.width / 2; break\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta\n    }\n    delta = 0\n\n    return sum\n  }\n}\n\nfunction width (g, v) {\n  return g.node(v).width\n}\n\nexport default {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n}\n","import _ from 'lodash'\n\nimport util from '../util'\nimport { positionX } from './bk'\n\nfunction position (g) {\n  g = util.asNonCompoundGraph(g)\n\n  positionY(g)\n  _.forEach(positionX(g), function (x, v) {\n    g.node(v).x = x\n  })\n}\n\nfunction positionY (g) {\n  const layering = util.buildLayerMatrix(g)\n  const rankSep = g.graph().ranksep\n  let prevY = 0\n  _.forEach(layering, function (layer) {\n    const maxHeight = _.max(_.map(layer, function (v) { return g.node(v).height }))\n    _.forEach(layer, function (v) {\n      g.node(v).y = prevY + maxHeight / 2\n    })\n    prevY += maxHeight + rankSep\n  })\n}\n\nexport default position\n","import _ from 'lodash'\n\nfunction addSubgraphConstraints (g, cg, vs) {\n  const prev = {}\n  let rootPrev\n\n  _.forEach(vs, function (v) {\n    let child = g.parent(v)\n    let parent\n    let prevChild\n    while (child) {\n      parent = g.parent(child)\n      if (parent) {\n        prevChild = prev[parent]\n        prev[parent] = child\n      } else {\n        prevChild = rootPrev\n        rootPrev = child\n      }\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child)\n        return\n      }\n      child = parent\n    }\n  })\n\n  /*\n  function dfs(v) {\n    const children = v ? g.children(v) : g.children();\n    if (children.length) {\n      const min = Number.POSITIVE_INFINITY,\n          subgraphs = [];\n      _.forEach(children, function(child) {\n        const childMin = dfs(child);\n        if (g.children(child).length) {\n          subgraphs.push({ v: child, order: childMin });\n        }\n        min = Math.min(min, childMin);\n      });\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\n        cg.setEdge(prev.v, curr.v);\n        return curr;\n      });\n      return min;\n    }\n    return g.node(v).order;\n  }\n  dfs(undefined);\n  */\n}\n\nexport default addSubgraphConstraints\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph (g, rank, relationship) {\n  const root = createRootNode(g)\n  const result = new Graph({ compound: true }).setGraph({ root: root })\n    .setDefaultNodeLabel(function (v) { return g.node(v) })\n\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    const parent = g.parent(v)\n\n    if (node.rank === rank || (node.minRank <= rank && rank <= node.maxRank)) {\n      result.setNode(v)\n      result.setParent(v, parent || root)\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function (e) {\n        const u = e.v === v ? e.w : e.v\n        const edge = result.edge(u, v)\n        const weight = !_.isUndefined(edge) ? edge.weight : 0\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight })\n      })\n\n      if (_.has(node, 'minRank')) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        })\n      }\n    }\n  })\n\n  return result\n}\n\nfunction createRootNode (g) {\n  let v\n  while (g.hasNode((v = _.uniqueId('_root'))));\n  return v\n}\n\nexport default buildLayerGraph\n","import _ from 'lodash'\n\nimport util from '../util'\n\nfunction sort (entries, biasRight) {\n  const parts = util.partition(entries, function (entry) {\n    return _.has(entry, 'barycenter')\n  })\n  const sortable = parts.lhs\n  const unsortable = _.sortBy(parts.rhs, function (entry) { return -entry.i })\n  const vs = []\n  let sum = 0\n  let weight = 0\n  let vsIndex = 0\n\n  sortable.sort(compareWithBias(!!biasRight))\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex)\n\n  _.forEach(sortable, function (entry) {\n    vsIndex += entry.vs.length\n    vs.push(entry.vs)\n    sum += entry.barycenter * entry.weight\n    weight += entry.weight\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex)\n  })\n\n  const result = { vs: _.flatten(vs, true) }\n  if (weight) {\n    result.barycenter = sum / weight\n    result.weight = weight\n  }\n  return result\n}\n\nfunction consumeUnsortable (vs, unsortable, index) {\n  let last\n  while (unsortable.length && (last = _.last(unsortable)).i <= index) {\n    unsortable.pop()\n    vs.push(last.vs)\n    index++\n  }\n  return index\n}\n\nfunction compareWithBias (bias) {\n  return function (entryV, entryW) {\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1\n    } else if (entryV.barycenter > entryW.barycenter) {\n      return 1\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i\n  }\n}\n\nexport default sort\n","import _ from 'lodash'\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts (entries, cg) {\n  const mappedEntries = {}\n  _.forEach(entries, function (entry, i) {\n    const tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      'in': [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    }\n    if (!_.isUndefined(entry.barycenter)) {\n      tmp.barycenter = entry.barycenter\n      tmp.weight = entry.weight\n    }\n  })\n\n  _.forEach(cg.edges(), function (e) {\n    const entryV = mappedEntries[e.v]\n    const entryW = mappedEntries[e.w]\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++\n      entryV.out.push(mappedEntries[e.w])\n    }\n  })\n\n  const sourceSet = _.filter(mappedEntries, function (entry) {\n    return !entry.indegree\n  })\n\n  return doResolveConflicts(sourceSet)\n}\n\nfunction doResolveConflicts (sourceSet) {\n  const entries = []\n\n  function handleIn (vEntry) {\n    return function (uEntry) {\n      if (uEntry.merged) {\n        return\n      }\n      if (_.isUndefined(uEntry.barycenter) ||\n          _.isUndefined(vEntry.barycenter) ||\n          uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry)\n      }\n    }\n  }\n\n  function handleOut (vEntry) {\n    return function (wEntry) {\n      wEntry['in'].push(vEntry)\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry)\n      }\n    }\n  }\n\n  while (sourceSet.length) {\n    const entry = sourceSet.pop()\n    entries.push(entry)\n    _.forEach(entry['in'].reverse(), handleIn(entry))\n    _.forEach(entry.out, handleOut(entry))\n  }\n\n  return _.chain(entries)\n    .filter(function (entry) { return !entry.merged })\n    .map(function (entry) {\n      return _.pick(entry, ['vs', 'i', 'barycenter', 'weight'])\n    })\n    .value()\n}\n\nfunction mergeEntries (target, source) {\n  let sum = 0\n  let weight = 0\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight\n    weight += target.weight\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight\n    weight += source.weight\n  }\n\n  target.vs = source.vs.concat(target.vs)\n  target.barycenter = sum / weight\n  target.weight = weight\n  target.i = Math.min(source.i, target.i)\n  source.merged = true\n}\n\nexport default resolveConflicts\n","import _ from 'lodash'\n\nfunction barycenter (g, movable) {\n  return _.map(movable, function (v) {\n    const inV = g.inEdges(v)\n    if (!inV.length) {\n      return { v: v }\n    } else {\n      const result = _.reduce(inV, function (acc, e) {\n        const edge = g.edge(e)\n        const nodeU = g.node(e.v)\n        return {\n          sum: acc.sum + (edge.weight * nodeU.order),\n          weight: acc.weight + edge.weight\n        }\n      }, { sum: 0, weight: 0 })\n\n      return {\n        v: v,\n        barycenter: result.sum / result.weight,\n        weight: result.weight\n      }\n    }\n  })\n}\n\nexport default barycenter\n","import _ from 'lodash'\n\nimport barycenter from './barycenter'\nimport resolveConflicts from './resolve-conflicts'\nimport sort from './sort'\n\nfunction sortSubgraph (g, v, cg, biasRight) {\n  let movable = g.children(v)\n  const node = g.node(v)\n  const bl = node ? node.borderLeft : undefined\n  const br = node ? node.borderRight : undefined\n  const subgraphs = {}\n\n  if (bl) {\n    movable = _.filter(movable, function (w) {\n      return w !== bl && w !== br\n    })\n  }\n\n  const barycenters = barycenter(g, movable)\n  _.forEach(barycenters, function (entry) {\n    if (g.children(entry.v).length) {\n      const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight)\n      subgraphs[entry.v] = subgraphResult\n      if (_.has(subgraphResult, 'barycenter')) {\n        mergeBarycenters(entry, subgraphResult)\n      }\n    }\n  })\n\n  const entries = resolveConflicts(barycenters, cg)\n  expandSubgraphs(entries, subgraphs)\n\n  const result = sort(entries, biasRight)\n\n  if (bl) {\n    result.vs = _.flatten([bl, result.vs, br], true)\n    if (g.predecessors(bl).length) {\n      const blPred = g.node(g.predecessors(bl)[0])\n      const brPred = g.node(g.predecessors(br)[0])\n      if (!_.has(result, 'barycenter')) {\n        result.barycenter = 0\n        result.weight = 0\n      }\n      result.barycenter = (result.barycenter * result.weight +\n                           blPred.order + brPred.order) / (result.weight + 2)\n      result.weight += 2\n    }\n  }\n\n  return result\n}\n\nfunction expandSubgraphs (entries, subgraphs) {\n  _.forEach(entries, function (entry) {\n    entry.vs = _.flatten(entry.vs.map(function (v) {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs\n      }\n      return v\n    }), true)\n  })\n}\n\nfunction mergeBarycenters (target, other) {\n  if (!_.isUndefined(target.barycenter)) {\n    target.barycenter = (target.barycenter * target.weight +\n                         other.barycenter * other.weight) /\n                        (target.weight + other.weight)\n    target.weight += other.weight\n  } else {\n    target.barycenter = other.barycenter\n    target.weight = other.weight\n  }\n}\n\nexport default sortSubgraph\n","import _ from 'lodash'\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount (g, layering) {\n  let cc = 0\n  for (let i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i])\n  }\n  return cc\n}\n\nfunction twoLayerCrossCount (g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  const southPos = _.zipObject(southLayer,\n    _.map(southLayer, function (v, i) { return i }))\n  const southEntries = _.flatten(_.map(northLayer, function (v) {\n    return _.chain(g.outEdges(v))\n      .map(function (e) {\n        return { pos: southPos[e.w], weight: g.edge(e).weight }\n      })\n      .sortBy('pos')\n      .value()\n  }), true)\n\n  // Build the accumulator tree\n  let firstIndex = 1\n  while (firstIndex < southLayer.length) {\n    firstIndex <<= 1\n  }\n  const treeSize = 2 * firstIndex - 1\n  firstIndex -= 1\n  const tree = _.map(new Array(treeSize), function () { return 0 })\n\n  // Calculate the weighted crossings\n  let cc = 0\n  _.forEach(southEntries.forEach(function (entry) {\n    let index = entry.pos + firstIndex\n    tree[index] += entry.weight\n    let weightSum = 0\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1]\n      }\n      index = (index - 1) >> 1\n      tree[index] += entry.weight\n    }\n    cc += entry.weight * weightSum\n  }))\n\n  return cc\n}\n\nexport default crossCount\n","import _ from 'lodash'\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nfunction initOrder (g) {\n  const visited = {}\n  const simpleNodes = _.filter(g.nodes(), function (v) {\n    return !g.children(v).length\n  })\n  const maxRank = _.max(_.map(simpleNodes, function (v) { return g.node(v).rank }))\n  const layers = _.map(_.range(maxRank + 1), function () { return [] })\n\n  function dfs (v) {\n    if (_.has(visited, v)) return\n    visited[v] = true\n    const node = g.node(v)\n    layers[node.rank].push(v)\n    _.forEach(g.successors(v), dfs)\n  }\n\n  const orderedVs = _.sortBy(simpleNodes, function (v) { return g.node(v).rank })\n  _.forEach(orderedVs, dfs)\n\n  return layers\n}\n\nexport default initOrder\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport initOrder from './init-order'\nimport crossCount from './cross-count'\nimport sortSubgraph from './sort-subgraph'\nimport buildLayerGraph from './build-layer-graph'\nimport addSubgraphConstraints from './add-subgraph-constraints'\nimport util from '../util'\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order (g) {\n  const maxRank = util.maxRank(g)\n  const downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), 'inEdges')\n  const upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), 'outEdges')\n\n  let layering = initOrder(g)\n  assignOrder(g, layering)\n\n  let bestCC = Number.POSITIVE_INFINITY\n  let best\n\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2)\n\n    layering = util.buildLayerMatrix(g)\n    const cc = crossCount(g, layering)\n    if (cc < bestCC) {\n      lastBest = 0\n      best = _.cloneDeep(layering)\n      bestCC = cc\n    }\n  }\n\n  assignOrder(g, best)\n}\n\nfunction buildLayerGraphs (g, ranks, relationship) {\n  return _.map(ranks, function (rank) {\n    return buildLayerGraph(g, rank, relationship)\n  })\n}\n\nfunction sweepLayerGraphs (layerGraphs, biasRight) {\n  const cg = new Graph()\n  _.forEach(layerGraphs, function (lg) {\n    const root = lg.graph().root\n    const sorted = sortSubgraph(lg, root, cg, biasRight)\n    _.forEach(sorted.vs, function (v, i) {\n      lg.node(v).order = i\n    })\n    addSubgraphConstraints(lg, cg, sorted.vs)\n  })\n}\n\nfunction assignOrder (g, layering) {\n  _.forEach(layering, function (layer) {\n    _.forEach(layer, function (v, i) {\n      g.node(v).order = i\n    })\n  })\n}\n\nexport default order\n","import _ from 'lodash'\n\nfunction adjust (g) {\n  const rankDir = g.graph().rankdir.toLowerCase()\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapWidthHeight(g)\n  }\n}\n\nfunction undo (g) {\n  const rankDir = g.graph().rankdir.toLowerCase()\n  if (rankDir === 'bt' || rankDir === 'rl') {\n    reverseY(g)\n  }\n\n  if (rankDir === 'lr' || rankDir === 'rl') {\n    swapXY(g)\n    swapWidthHeight(g)\n  }\n}\n\nfunction swapWidthHeight (g) {\n  _.forEach(g.nodes(), function (v) { swapWidthHeightOne(g.node(v)) })\n  _.forEach(g.edges(), function (e) { swapWidthHeightOne(g.edge(e)) })\n}\n\nfunction swapWidthHeightOne (attrs) {\n  const w = attrs.width\n  attrs.width = attrs.height\n  attrs.height = w\n}\n\nfunction reverseY (g) {\n  _.forEach(g.nodes(), function (v) { reverseYOne(g.node(v)) })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, reverseYOne)\n    if (_.has(edge, 'y')) {\n      reverseYOne(edge)\n    }\n  })\n}\n\nfunction reverseYOne (attrs) {\n  attrs.y = -attrs.y\n}\n\nfunction swapXY (g) {\n  _.forEach(g.nodes(), function (v) { swapXYOne(g.node(v)) })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, swapXYOne)\n    if (_.has(edge, 'x')) {\n      swapXYOne(edge)\n    }\n  })\n}\n\nfunction swapXYOne (attrs) {\n  const x = attrs.x\n  attrs.x = attrs.y\n  attrs.y = x\n}\n\nexport default {\n  adjust,\n  undo\n}\n","import _ from 'lodash'\n\nimport util from './util'\n\nfunction addBorderSegments (g) {\n  function dfs (v) {\n    const children = g.children(v)\n    const node = g.node(v)\n    if (children.length) {\n      _.forEach(children, dfs)\n    }\n\n    if (_.has(node, 'minRank')) {\n      node.borderLeft = []\n      node.borderRight = []\n      for (let rank = node.minRank, maxRank = node.maxRank + 1;\n        rank < maxRank;\n        ++rank) {\n        addBorderNode(g, 'borderLeft', '_bl', v, node, rank)\n        addBorderNode(g, 'borderRight', '_br', v, node, rank)\n      }\n    }\n  }\n\n  _.forEach(g.children(), dfs)\n}\n\nfunction addBorderNode (g, prop, prefix, sg, sgNode, rank) {\n  const label = { width: 0, height: 0, rank: rank, borderType: prop }\n  const prev = sgNode[prop][rank - 1]\n  const curr = util.addDummyNode(g, 'border', label, prefix)\n  sgNode[prop][rank] = curr\n  g.setParent(curr, sg)\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 })\n  }\n}\n\nexport default addBorderSegments\n","import _ from 'lodash'\n\nimport util from './util'\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run (g) {\n  const root = util.addDummyNode(g, 'root', {}, '_root')\n  const depths = treeDepths(g)\n  const height = _.max(_.values(depths)) - 1\n  const nodeSep = 2 * height + 1\n\n  g.graph().nestingRoot = root\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _.forEach(g.edges(), function (e) { g.edge(e).minlen *= nodeSep })\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  const weight = sumWeights(g) + 1\n\n  // Create border nodes and link them up\n  _.forEach(g.children(), function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child)\n  })\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep\n}\n\nfunction dfs (g, root, nodeSep, weight, height, depths, v) {\n  const children = g.children(v)\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep })\n    }\n    return\n  }\n\n  const top = util.addBorderNode(g, '_bt')\n  const bottom = util.addBorderNode(g, '_bb')\n  const label = g.node(v)\n\n  g.setParent(top, v)\n  label.borderTop = top\n  g.setParent(bottom, v)\n  label.borderBottom = bottom\n\n  _.forEach(children, function (child) {\n    dfs(g, root, nodeSep, weight, height, depths, child)\n\n    const childNode = g.node(child)\n    const childTop = childNode.borderTop ? childNode.borderTop : child\n    const childBottom = childNode.borderBottom ? childNode.borderBottom : child\n    const thisWeight = childNode.borderTop ? weight : 2 * weight\n    const minlen = childTop !== childBottom ? 1 : height - depths[v] + 1\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    })\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    })\n  })\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] })\n  }\n}\n\nfunction treeDepths (g) {\n  const depths = {}\n  function dfs (v, depth) {\n    const children = g.children(v)\n    if (children && children.length) {\n      _.forEach(children, function (child) {\n        dfs(child, depth + 1)\n      })\n    }\n    depths[v] = depth\n  }\n  _.forEach(g.children(), function (v) { dfs(v, 1) })\n  return depths\n}\n\nfunction sumWeights (g) {\n  return _.reduce(g.edges(), function (acc, e) {\n    return acc + g.edge(e).weight\n  }, 0)\n}\n\nfunction cleanup (g) {\n  const graphLabel = g.graph()\n  g.removeNode(graphLabel.nestingRoot)\n  delete graphLabel.nestingRoot\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.nestingEdge) {\n      g.removeEdge(e)\n    }\n  })\n}\n\nexport default {\n  run,\n  cleanup\n}\n","import _ from 'lodash'\n\nfunction parentDummyChains (g) {\n  const postorderNums = postorder(g)\n\n  _.forEach(g.graph().dummyChains, function (v) {\n    let node = g.node(v)\n    const edgeObj = node.edgeObj\n    const pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w)\n    const path = pathData.path\n    const lca = pathData.lca\n    let pathIdx = 0\n    let pathV = path[pathIdx]\n    let ascending = true\n\n    while (v !== edgeObj.w) {\n      node = g.node(v)\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca &&\n               g.node(pathV).maxRank < node.rank) {\n          pathIdx++\n        }\n\n        if (pathV === lca) {\n          ascending = false\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 &&\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++\n        }\n        pathV = path[pathIdx]\n      }\n\n      g.setParent(v, pathV)\n      v = g.successors(v)[0]\n    }\n  })\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath (g, postorderNums, v, w) {\n  const vPath = []\n  const wPath = []\n  const low = Math.min(postorderNums[v].low, postorderNums[w].low)\n  const lim = Math.max(postorderNums[v].lim, postorderNums[w].lim)\n  let parent\n  let lca\n\n  // Traverse up from v to find the LCA\n  parent = v\n  do {\n    parent = g.parent(parent)\n    vPath.push(parent)\n  } while (parent &&\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim))\n  lca = parent\n\n  // Traverse from w to LCA\n  parent = w\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent)\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca }\n}\n\nfunction postorder (g) {\n  const result = {}\n  let lim = 0\n\n  function dfs (v) {\n    const low = lim\n    _.forEach(g.children(v), dfs)\n    result[v] = { low: low, lim: lim++ }\n  }\n  _.forEach(g.children(), dfs)\n\n  return result\n}\n\nexport default parentDummyChains\n","import _ from 'lodash'\nimport { alg } from 'graphlibrary'\n\nimport feasibleTree from './feasible-tree'\nimport { slack, longestPath as initRank } from './util'\nimport { simplify } from '../util'\n\nconst { preorder, postorder } = alg\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues\nnetworkSimplex.initCutValues = initCutValues\nnetworkSimplex.calcCutValue = calcCutValue\nnetworkSimplex.leaveEdge = leaveEdge\nnetworkSimplex.enterEdge = enterEdge\nnetworkSimplex.exchangeEdges = exchangeEdges\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex (g) {\n  g = simplify(g)\n  initRank(g)\n  const t = feasibleTree(g)\n  initLowLimValues(t)\n  initCutValues(t, g)\n\n  let e\n  let f\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e)\n    exchangeEdges(t, g, e, f)\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues (t, g) {\n  let vs = postorder(t, t.nodes())\n  vs = vs.slice(0, vs.length - 1)\n  _.forEach(vs, function (v) {\n    assignCutValue(t, g, v)\n  })\n}\n\nfunction assignCutValue (t, g, child) {\n  const childLab = t.node(child)\n  const parent = childLab.parent\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child)\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue (t, g, child) {\n  const childLab = t.node(child)\n  const parent = childLab.parent\n  // True if the child is on the tail end of the edge in the directed graph\n  let childIsTail = true\n  // The graph's view of the tree edge we're inspecting\n  let graphEdge = g.edge(child, parent)\n  // The accumulated cut value for the edge between this node and its parent\n  let cutValue = 0\n\n  if (!graphEdge) {\n    childIsTail = false\n    graphEdge = g.edge(parent, child)\n  }\n\n  cutValue = graphEdge.weight\n\n  _.forEach(g.nodeEdges(child), function (e) {\n    const isOutEdge = e.v === child\n    const other = isOutEdge ? e.w : e.v\n\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail\n      const otherWeight = g.edge(e).weight\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight\n      if (isTreeEdge(t, child, other)) {\n        const otherCutValue = t.edge(child, other).cutvalue\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue\n      }\n    }\n  })\n\n  return cutValue\n}\n\nfunction initLowLimValues (tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0]\n  }\n  dfsAssignLowLim(tree, {}, 1, root)\n}\n\nfunction dfsAssignLowLim (tree, visited, nextLim, v, parent) {\n  const low = nextLim\n  const label = tree.node(v)\n\n  visited[v] = true\n  _.forEach(tree.neighbors(v), function (w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v)\n    }\n  })\n\n  label.low = low\n  label.lim = nextLim++\n  if (parent) {\n    label.parent = parent\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent\n  }\n\n  return nextLim\n}\n\nfunction leaveEdge (tree) {\n  return _.find(tree.edges(), function (e) {\n    return tree.edge(e).cutvalue < 0\n  })\n}\n\nfunction enterEdge (t, g, edge) {\n  let v = edge.v\n  let w = edge.w\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w\n    w = edge.v\n  }\n\n  const vLabel = t.node(v)\n  const wLabel = t.node(w)\n  let tailLabel = vLabel\n  let flip = false\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel\n    flip = true\n  }\n\n  const candidates = _.filter(g.edges(), function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel)\n  })\n\n  return _.minBy(candidates, function (edge) { return slack(g, edge) })\n}\n\nfunction exchangeEdges (t, g, e, f) {\n  const v = e.v\n  const w = e.w\n  t.removeEdge(v, w)\n  t.setEdge(f.v, f.w, {})\n  initLowLimValues(t)\n  initCutValues(t, g)\n  updateRanks(t, g)\n}\n\nfunction updateRanks (t, g) {\n  const root = _.find(t.nodes(), function (v) { return !g.node(v).parent })\n  let vs = preorder(t, root)\n  vs = vs.slice(1)\n  _.forEach(vs, function (v) {\n    const parent = t.node(v).parent\n    let edge = g.edge(v, parent)\n    let flipped = false\n\n    if (!edge) {\n      edge = g.edge(parent, v)\n      flipped = true\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen)\n  })\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge (tree, u, v) {\n  return tree.hasEdge(u, v)\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant (tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim\n}\n\nexport default networkSimplex\n","import { longestPath } from './util'\nimport feasibleTree from './feasible-tree'\nimport networkSimplex from './network-simplex'\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank (g) {\n  switch (g.graph().ranker) {\n    case 'network-simplex': networkSimplexRanker(g); break\n    case 'tight-tree': tightTreeRanker(g); break\n    case 'longest-path': longestPathRanker(g); break\n    default: networkSimplexRanker(g)\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nconst longestPathRanker = longestPath\n\nfunction tightTreeRanker (g) {\n  longestPath(g)\n  feasibleTree(g)\n}\n\nfunction networkSimplexRanker (g) {\n  networkSimplex(g)\n}\n\nexport default rank\n","import _ from 'lodash'\n\nimport util from './util'\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run (g) {\n  g.graph().dummyChains = []\n  _.forEach(g.edges(), function (edge) { normalizeEdge(g, edge) })\n}\n\nfunction normalizeEdge (g, e) {\n  let v = e.v\n  let vRank = g.node(v).rank\n  const w = e.w\n  const wRank = g.node(w).rank\n  const name = e.name\n  const edgeLabel = g.edge(e)\n  const labelRank = edgeLabel.labelRank\n\n  if (wRank === vRank + 1) return\n\n  g.removeEdge(e)\n\n  let dummy\n  let attrs\n  let i\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = []\n    attrs = {\n      width: 0,\n      height: 0,\n      edgeLabel: edgeLabel,\n      edgeObj: e,\n      rank: vRank\n    }\n    dummy = util.addDummyNode(g, 'edge', attrs, '_d')\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width\n      attrs.height = edgeLabel.height\n      attrs.dummy = 'edge-label'\n      attrs.labelpos = edgeLabel.labelpos\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name)\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy)\n    }\n    v = dummy\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name)\n}\n\nfunction undo (g) {\n  _.forEach(g.graph().dummyChains, function (v) {\n    let node = g.node(v)\n    const origLabel = node.edgeLabel\n    let w = null\n    g.setEdge(node.edgeObj, origLabel)\n    while (node.dummy) {\n      w = g.successors(v)[0]\n      g.removeNode(v)\n      origLabel.points.push({ x: node.x, y: node.y })\n      if (node.dummy === 'edge-label') {\n        origLabel.x = node.x\n        origLabel.y = node.y\n        origLabel.width = node.width\n        origLabel.height = node.height\n      }\n      v = w\n      node = g.node(v)\n    }\n  })\n}\n\nexport default {\n  run,\n  undo\n}\n","/*\n * Simple doubly linked list implementation derived from Cormen, et al.,\n * \"Introduction to Algorithms\".\n */\n\nfunction List () {\n  const sentinel = {}\n  sentinel._next = sentinel._prev = sentinel\n  this._sentinel = sentinel\n}\n\nList.prototype.dequeue = function () {\n  const sentinel = this._sentinel\n  const entry = sentinel._prev\n  if (entry !== sentinel) {\n    unlink(entry)\n    return entry\n  }\n}\n\nList.prototype.enqueue = function (entry) {\n  const sentinel = this._sentinel\n  if (entry._prev && entry._next) {\n    unlink(entry)\n  }\n  entry._next = sentinel._next\n  sentinel._next._prev = entry\n  sentinel._next = entry\n  entry._prev = sentinel\n}\n\nList.prototype.toString = function () {\n  const strs = []\n  const sentinel = this._sentinel\n  let curr = sentinel._prev\n  while (curr !== sentinel) {\n    strs.push(JSON.stringify(curr, filterOutLinks))\n    curr = curr._prev\n  }\n  return '[' + strs.join(', ') + ']'\n}\n\nfunction unlink (entry) {\n  entry._prev._next = entry._next\n  entry._next._prev = entry._prev\n  delete entry._next\n  delete entry._prev\n}\n\nfunction filterOutLinks (k, v) {\n  if (k !== '_next' && k !== '_prev') {\n    return v\n  }\n}\n\nexport default List\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport List from './data/list'\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\n\nconst DEFAULT_WEIGHT_FN = _.constant(1)\n\nfunction greedyFAS (g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return []\n  }\n  const state = buildState(g, weightFn || DEFAULT_WEIGHT_FN)\n  const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx)\n\n  // Expand multi-edges\n  return _.flatten(_.map(results, function (e) {\n    return g.outEdges(e.v, e.w)\n  }), true)\n}\n\nfunction doGreedyFAS (g, buckets, zeroIdx) {\n  let results = []\n  const sources = buckets[buckets.length - 1]\n  const sinks = buckets[0]\n\n  let entry\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue())) { removeNode(g, buckets, zeroIdx, entry) }\n    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry) }\n    if (g.nodeCount()) {\n      for (let i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue()\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true))\n          break\n        }\n      }\n    }\n  }\n\n  return results\n}\n\nfunction removeNode (g, buckets, zeroIdx, entry, collectPredecessors) {\n  const results = collectPredecessors ? [] : undefined\n\n  _.forEach(g.inEdges(entry.v), function (edge) {\n    const weight = g.edge(edge)\n    const uEntry = g.node(edge.v)\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w })\n    }\n\n    uEntry.out -= weight\n    assignBucket(buckets, zeroIdx, uEntry)\n  })\n\n  _.forEach(g.outEdges(entry.v), function (edge) {\n    const weight = g.edge(edge)\n    const w = edge.w\n    const wEntry = g.node(w)\n    wEntry['in'] -= weight\n    assignBucket(buckets, zeroIdx, wEntry)\n  })\n\n  g.removeNode(entry.v)\n\n  return results\n}\n\nfunction buildState (g, weightFn) {\n  const fasGraph = new Graph()\n  let maxIn = 0\n  let maxOut = 0\n\n  _.forEach(g.nodes(), function (v) {\n    fasGraph.setNode(v, { v: v, 'in': 0, out: 0 })\n  })\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _.forEach(g.edges(), function (e) {\n    const prevWeight = fasGraph.edge(e.v, e.w) || 0\n    const weight = weightFn(e)\n    const edgeWeight = prevWeight + weight\n    fasGraph.setEdge(e.v, e.w, edgeWeight)\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight)\n    maxIn = Math.max(maxIn, fasGraph.node(e.w)['in'] += weight)\n  })\n\n  const buckets = _.range(maxOut + maxIn + 3).map(function () { return new List() })\n  const zeroIdx = maxIn + 1\n\n  _.forEach(fasGraph.nodes(), function (v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v))\n  })\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx }\n}\n\nfunction assignBucket (buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry)\n  } else if (!entry['in']) {\n    buckets[buckets.length - 1].enqueue(entry)\n  } else {\n    buckets[entry.out - entry['in'] + zeroIdx].enqueue(entry)\n  }\n}\n\nexport default greedyFAS\n","import _ from 'lodash'\n\nimport greedyFAS from './greedy-fas'\n\nfunction run (g) {\n  const fas = (g.graph().acyclicer === 'greedy'\n    ? greedyFAS(g, weightFn(g))\n    : dfsFAS(g))\n  _.forEach(fas, function (e) {\n    const label = g.edge(e)\n    g.removeEdge(e)\n    label.forwardName = e.name\n    label.reversed = true\n    g.setEdge(e.w, e.v, label, _.uniqueId('rev'))\n  })\n\n  function weightFn (g) {\n    return function (e) {\n      return g.edge(e).weight\n    }\n  }\n}\n\nfunction dfsFAS (g) {\n  const fas = []\n  const stack = {}\n  const visited = {}\n\n  function dfs (v) {\n    if (_.has(visited, v)) {\n      return\n    }\n    visited[v] = true\n    stack[v] = true\n    _.forEach(g.outEdges(v), function (e) {\n      if (_.has(stack, e.w)) {\n        fas.push(e)\n      } else {\n        dfs(e.w)\n      }\n    })\n    delete stack[v]\n  }\n\n  _.forEach(g.nodes(), dfs)\n  return fas\n}\n\nfunction undo (g) {\n  _.forEach(g.edges(), function (e) {\n    const label = g.edge(e)\n    if (label.reversed) {\n      g.removeEdge(e)\n\n      const forwardName = label.forwardName\n      delete label.reversed\n      delete label.forwardName\n      g.setEdge(e.w, e.v, label, forwardName)\n    }\n  })\n}\n\nexport default {\n  run,\n  undo\n}\n","import _ from 'lodash'\nimport { Graph } from 'graphlibrary'\n\nimport acyclic from './acyclic'\nimport normalize from './normalize'\nimport rank from './rank'\nimport util, { normalizeRanks, removeEmptyRanks } from './util'\nimport parentDummyChains from './parent-dummy-chains'\nimport nestingGraph from './nesting-graph'\nimport addBorderSegments from './add-border-segments'\nimport coordinateSystem from './coordinate-system'\nimport order from './order'\nimport position from './position'\n\nfunction layout (g, opts) {\n  const time = opts && opts.debugTiming ? util.time : util.notime\n  time('layout', function () {\n    const layoutGraph = time('  buildLayoutGraph',\n      function () { return buildLayoutGraph(g) })\n    time('  runLayout', function () { runLayout(layoutGraph, time) })\n    time('  updateInputGraph', function () { updateInputGraph(g, layoutGraph) })\n  })\n}\n\nfunction runLayout (g, time) {\n  time('    makeSpaceForEdgeLabels', function () { makeSpaceForEdgeLabels(g) })\n  time('    removeSelfEdges', function () { removeSelfEdges(g) })\n  time('    acyclic', function () { acyclic.run(g) })\n  time('    nestingGraph.run', function () { nestingGraph.run(g) })\n  time('    rank', function () { rank(util.asNonCompoundGraph(g)) })\n  time('    injectEdgeLabelProxies', function () { injectEdgeLabelProxies(g) })\n  time('    removeEmptyRanks', function () { removeEmptyRanks(g) })\n  time('    nestingGraph.cleanup', function () { nestingGraph.cleanup(g) })\n  time('    normalizeRanks', function () { normalizeRanks(g) })\n  time('    assignRankMinMax', function () { assignRankMinMax(g) })\n  time('    removeEdgeLabelProxies', function () { removeEdgeLabelProxies(g) })\n  time('    normalize.run', function () { normalize.run(g) })\n  time('    parentDummyChains', function () { parentDummyChains(g) })\n  time('    addBorderSegments', function () { addBorderSegments(g) })\n  time('    order', function () { order(g) })\n  time('    insertSelfEdges', function () { insertSelfEdges(g) })\n  time('    adjustCoordinateSystem', function () { coordinateSystem.adjust(g) })\n  time('    position', function () { position(g) })\n  time('    positionSelfEdges', function () { positionSelfEdges(g) })\n  time('    removeBorderNodes', function () { removeBorderNodes(g) })\n  time('    normalize.undo', function () { normalize.undo(g) })\n  time('    fixupEdgeLabelCoords', function () { fixupEdgeLabelCoords(g) })\n  time('    undoCoordinateSystem', function () { coordinateSystem.undo(g) })\n  time('    translateGraph', function () { translateGraph(g) })\n  time('    assignNodeIntersects', function () { assignNodeIntersects(g) })\n  time('    reversePoints', function () { reversePointsForReversedEdges(g) })\n  time('    acyclic.undo', function () { acyclic.undo(g) })\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph (inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function (v) {\n    const inputLabel = inputGraph.node(v)\n    const layoutLabel = layoutGraph.node(v)\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x\n      inputLabel.y = layoutLabel.y\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width\n        inputLabel.height = layoutLabel.height\n      }\n    }\n  })\n\n  _.forEach(inputGraph.edges(), function (e) {\n    const inputLabel = inputGraph.edge(e)\n    const layoutLabel = layoutGraph.edge(e)\n\n    inputLabel.points = layoutLabel.points\n    if (_.has(layoutLabel, 'x')) {\n      inputLabel.x = layoutLabel.x\n      inputLabel.y = layoutLabel.y\n    }\n  })\n\n  inputGraph.graph().width = layoutGraph.graph().width\n  inputGraph.graph().height = layoutGraph.graph().height\n}\n\nconst graphNumAttrs = ['nodesep', 'edgesep', 'ranksep', 'marginx', 'marginy']\nconst graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: 'tb' }\nconst graphAttrs = ['acyclicer', 'ranker', 'rankdir', 'align']\nconst nodeNumAttrs = ['width', 'height']\nconst nodeDefaults = { width: 0, height: 0 }\nconst edgeNumAttrs = ['minlen', 'weight', 'width', 'height', 'labeloffset']\nconst edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: 'r'\n}\nconst edgeAttrs = ['labelpos']\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph (inputGraph) {\n  const g = new Graph({ multigraph: true, compound: true })\n  const graph = canonicalize(inputGraph.graph())\n\n  g.setGraph(_.merge({},\n    graphDefaults,\n    selectNumberAttrs(graph, graphNumAttrs),\n    _.pick(graph, graphAttrs)))\n\n  _.forEach(inputGraph.nodes(), function (v) {\n    const node = canonicalize(inputGraph.node(v))\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults))\n    g.setParent(v, inputGraph.parent(v))\n  })\n\n  _.forEach(inputGraph.edges(), function (e) {\n    const edge = canonicalize(inputGraph.edge(e))\n    g.setEdge(e, _.merge({},\n      edgeDefaults,\n      selectNumberAttrs(edge, edgeNumAttrs),\n      _.pick(edge, edgeAttrs)))\n  })\n\n  return g\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels (g) {\n  const graph = g.graph()\n  graph.ranksep /= 2\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    edge.minlen *= 2\n    if (edge.labelpos.toLowerCase() !== 'c') {\n      if (graph.rankdir === 'TB' || graph.rankdir === 'BT') {\n        edge.width += edge.labeloffset\n      } else {\n        edge.height += edge.labeloffset\n      }\n    }\n  })\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.width && edge.height) {\n      const v = g.node(e.v)\n      const w = g.node(e.w)\n      const label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e }\n      util.addDummyNode(g, 'edge-proxy', label, '_ep')\n    }\n  })\n}\n\nfunction assignRankMinMax (g) {\n  let maxRank = 0\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank\n      node.maxRank = g.node(node.borderBottom).rank\n      maxRank = Math.max(maxRank, node.maxRank)\n    }\n  })\n  g.graph().maxRank = maxRank\n}\n\nfunction removeEdgeLabelProxies (g) {\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.dummy === 'edge-proxy') {\n      g.edge(node.e).labelRank = node.rank\n      g.removeNode(v)\n    }\n  })\n}\n\nfunction translateGraph (g) {\n  let minX = Number.POSITIVE_INFINITY\n  let maxX = 0\n  let minY = Number.POSITIVE_INFINITY\n  let maxY = 0\n  const graphLabel = g.graph()\n  const marginX = graphLabel.marginx || 0\n  const marginY = graphLabel.marginy || 0\n\n  function getExtremes (attrs) {\n    const x = attrs.x\n    const y = attrs.y\n    const w = attrs.width\n    const h = attrs.height\n    minX = Math.min(minX, x - w / 2)\n    maxX = Math.max(maxX, x + w / 2)\n    minY = Math.min(minY, y - h / 2)\n    maxY = Math.max(maxY, y + h / 2)\n  }\n\n  _.forEach(g.nodes(), function (v) { getExtremes(g.node(v)) })\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (_.has(edge, 'x')) {\n      getExtremes(edge)\n    }\n  })\n\n  minX -= marginX\n  minY -= marginY\n\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    node.x -= minX\n    node.y -= minY\n  })\n\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    _.forEach(edge.points, function (p) {\n      p.x -= minX\n      p.y -= minY\n    })\n    if (_.has(edge, 'x')) { edge.x -= minX }\n    if (_.has(edge, 'y')) { edge.y -= minY }\n  })\n\n  graphLabel.width = maxX - minX + marginX\n  graphLabel.height = maxY - minY + marginY\n}\n\nfunction assignNodeIntersects (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    const nodeV = g.node(e.v)\n    const nodeW = g.node(e.w)\n    let p1 = null\n    let p2 = null\n    if (!edge.points) {\n      edge.points = []\n      p1 = nodeW\n      p2 = nodeV\n    } else {\n      p1 = edge.points[0]\n      p2 = edge.points[edge.points.length - 1]\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1))\n    edge.points.push(util.intersectRect(nodeW, p2))\n  })\n}\n\nfunction fixupEdgeLabelCoords (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (_.has(edge, 'x')) {\n      if (edge.labelpos === 'l' || edge.labelpos === 'r') {\n        edge.width -= edge.labeloffset\n      }\n      switch (edge.labelpos) {\n        case 'l': edge.x -= edge.width / 2 + edge.labeloffset; break\n        case 'r': edge.x += edge.width / 2 + edge.labeloffset; break\n      }\n    }\n  })\n}\n\nfunction reversePointsForReversedEdges (g) {\n  _.forEach(g.edges(), function (e) {\n    const edge = g.edge(e)\n    if (edge.reversed) {\n      edge.points.reverse()\n    }\n  })\n}\n\nfunction removeBorderNodes (g) {\n  _.forEach(g.nodes(), function (v) {\n    if (g.children(v).length) {\n      const node = g.node(v)\n      const t = g.node(node.borderTop)\n      const b = g.node(node.borderBottom)\n      const l = g.node(_.last(node.borderLeft))\n      const r = g.node(_.last(node.borderRight))\n\n      node.width = Math.abs(r.x - l.x)\n      node.height = Math.abs(b.y - t.y)\n      node.x = l.x + node.width / 2\n      node.y = t.y + node.height / 2\n    }\n  })\n\n  _.forEach(g.nodes(), function (v) {\n    if (g.node(v).dummy === 'border') {\n      g.removeNode(v)\n    }\n  })\n}\n\nfunction removeSelfEdges (g) {\n  _.forEach(g.edges(), function (e) {\n    if (e.v === e.w) {\n      const node = g.node(e.v)\n      if (!node.selfEdges) {\n        node.selfEdges = []\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) })\n      g.removeEdge(e)\n    }\n  })\n}\n\nfunction insertSelfEdges (g) {\n  const layers = util.buildLayerMatrix(g)\n  _.forEach(layers, function (layer) {\n    let orderShift = 0\n    _.forEach(layer, function (v, i) {\n      const node = g.node(v)\n      node.order = i + orderShift\n      _.forEach(node.selfEdges, function (selfEdge) {\n        util.addDummyNode(g, 'selfedge', {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + (++orderShift),\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, '_se')\n      })\n      delete node.selfEdges\n    })\n  })\n}\n\nfunction positionSelfEdges (g) {\n  _.forEach(g.nodes(), function (v) {\n    const node = g.node(v)\n    if (node.dummy === 'selfedge') {\n      const selfNode = g.node(node.e.v)\n      const x = selfNode.x + selfNode.width / 2\n      const y = selfNode.y\n      const dx = node.x - x\n      const dy = selfNode.height / 2\n      g.setEdge(node.e, node.label)\n      g.removeNode(v)\n      node.label.points = [\n        { x: x + 2 * dx / 3, y: y - dy },\n        { x: x + 5 * dx / 6, y: y - dy },\n        { x: x + dx, y: y },\n        { x: x + 5 * dx / 6, y: y + dy },\n        { x: x + 2 * dx / 3, y: y + dy }\n      ]\n      node.label.x = node.x\n      node.label.y = node.y\n    }\n  })\n}\n\nfunction selectNumberAttrs (obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number)\n}\n\nfunction canonicalize (attrs) {\n  const newAttrs = {}\n  _.forEach(attrs, function (v, k) {\n    newAttrs[k.toLowerCase()] = v\n  })\n  return newAttrs\n}\n\nexport default layout\n","import layout from './lib/layout'\n\nexport default {\n  layout\n}\n"],"sourceRoot":""}