# 1.1 Docker

### 什么是容器化应用

containerized applications 指容器化的应用，我们常常说使用镜像打包应用程序，使用 Docker 发布、部署应用程序，那么当你的应用成功在 Docker 上运行时，称这个应用是 containerized applications。





Linux 内核的用途是什么？

内存管理：追踪记录有多少内存存储了什么以及存储在哪里

进程管理：确定哪些进程可以使用中央处理器（CPU）、何时使		    用以及持续多长时间

设备驱动程序：充当硬件与进程之间的调解程序/解释程序

系统调用和安全防护：从流程接受服务请求

![linux_kernel](H:\文章\K8S基础教程\1.basic\.images\linux_kernel.jpg)

![linux_docker](H:\文章\K8S基础教程\1.basic\.images\linux_docker.jpg)



### 应用怎么打包

编写 Dockerfile 文件	       -- 定义构建镜像的流程

选择一个基础镜像（操作系统）           -- 操作系统

安装应用的需要的环境		 -- 环境

复制程序文件			 -- 应用

开始镜像的制作			-- 生成镜像

Docker 镜像组成

![1633930417(H:\文章\K8S基础教程\1.basic\.images\1633930417(1).jpg)](./.images/1633930417(1).jpg)

通常Docker镜像中只有一个精简的Shell，甚至没有Shell。镜像中还不包含内核——容器都是共享所在Docker主机的内核。所以有时会说容器仅包含必要的操作系统（通常只有操作系统文件和文件系统对象）。

![docker_dotnet](H:\文章\K8S基础教程\1.basic\.images\docker_dotnet.jpg)



### Docker 工作流程

![docker_work1](H:\文章\K8S基础教程\1.basic\.images\docker_work1.jpg)

![docker_work2](H:\文章\K8S基础教程\1.basic\.images\docker_work2.jpg)

## Docker 结构



### Docker 服务与客户端

```
Client: Docker Engine - Community
 Version:           20.10.7
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        f0df350
 Built:             Wed Jun  2 11:58:10 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.7
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       b0f5bc3
  Built:            Wed Jun  2 11:56:35 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.6
  GitCommit:        d71fcd7d8303cbf684402823e425e9dd2e99285d
 runc:
  Version:          1.0.0-rc95
  GitCommit:        b9ee9c6314599f1b4a7f497e1f1f856fe433d3b7
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```

> 执行 docker  version 查看版本号



### Docker客户端

Docker客户(DockerClient） 是一个命令行程序，使用 Go 语言编写，我们也可以使用 C#、Java 等语言写一个。

客户端通讯

Docker 客户端和服务端使用 REST API、UNIX 套接字或网络接口进行通信。
Docker 客户端 ( docker) 是许多 Docker 用户与 Docker 交互的主要方式。当您使用诸如 之类的命令时docker run，客户端会将这些命令发送到dockerd，从而执行它们。

什么是域套接字

在 Linux 中，有很多进程，为了让多个进程能够进行通讯，出现和很多方法，其中一种是套接字(socket)。一般的 socket 都是基于 TCP/IP 的，称为网络套接字，可以实现跨主机进程通讯。在 Linux 中有一种套接字，名为域套接字，只能用于在同一计算机中的进程间通讯，但是其效率高于网络套接字。域套接字使用一个 .sock 文件进行通讯。

| 运行时     | 域套接字                        |
| ---------- | ------------------------------- |
| Docker     | /var/run/dockershim.sock        |
| containerd | /run/containerd/containerd.sock |
| CRI-O      | /var/run/crio/crio.sock         |

![docker_client_server](H:\文章\K8S基础教程\1.basic\.images\docker_client_server.jpg)

### Docker引擎

Docker 引擎由 Docker守护进程（Docker daemon）、containerd以及runc组成。

Docker daemon

Docker 守护进程 ( dockerd) 侦听 Docker API 请求并管理 Docker 对象，例如图像、容器、网络和卷。

![docker_daemon](H:\文章\K8S基础教程\1.basic\.images\docker_daemon.jpg)

### Docker旧版本引擎

Docker首次发布时，Docker引擎由两个核心组件构成：LXC和Docker daemon。

LXC (Linux Container)是 Linux 提供的一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。

LXC提供了对诸如命名空间（Namespace）和控制组（CGroup）等基础工具的操作能力，它们是基于Linux内核的容器虚拟化技术。

Docker 抛弃 LXC

首先，LXC 是基于 Linux 的。这对于一个立志于跨平台的项目来说是个问题。其次，如此核心的组件依赖于外部工具，这会给项目带来巨大风险，甚至影响其发展。

![docker_lxc](H:\文章\K8S基础教程\1.basic\.images\docker_lxc.jpg)

### Docker引擎的架构

containerd

containerd 位于 daemon 和 runc 所在的 OCI 层之间。
它的主要任务是容器的生命周期管理：
——start | stop | pause | rm....

shim

容器运行时 shim 是一种位于容器管理器和容器运行时（runc、crun）之间的软件，
用于解决这些对应物的集成问题。
它的作用非常单一，那就是实现 CRI 规定的每个接口，然后把具体的 CRI 请求“翻译”成对后端容器项目的请求或者操作。

runc

runc 实质上是一个轻量级的、针对 Libcontainer 进行了包装的命令行交互工具（Libcontainer取代了早期Docker架构中的LXC）。
runc 生来只有一个作用——创建容器

OCI定义了容器运行时标准，runC是Docker按照开放容器格式标准制定的一种具体实现。

![docker_struct](H:\文章\K8S基础教程\1.basic\.images\docker_struct.jpg)

![docker_struct2](H:\文章\K8S基础教程\1.basic\.images\docker_struct2.jpg)



## Docker核心技术

### Linux-Namespace

Namespace 是 Linux 内核提供的一种资源隔离技术，目前实现了以下7种资源隔离，Docker 也基本在这七种资源上对容器环境进行隔离。

![docker_namespace](H:\文章\K8S基础教程\1.basic\.images\linux_namespace.jpg)



### Linux-进程树

Linux的进程有父进程、子进程之分；将进程间的关系绘制出来，就会发现是一个“树”的结构。

![linuxps](H:\文章\K8S基础教程\1.basic\.images\linuxps.jpg)

![linux_process](H:\文章\K8S基础教程\1.basic\.images\linux_process.jpg)





#### Docker-Namespace 进程隔离

![docker_run1](H:\文章\K8S基础教程\1.basic\.images\docker_run1.jpg)

![docker_run2](H:\文章\K8S基础教程\1.basic\.images\docker_run2.jpg)

![docker_run3](H:\文章\K8S基础教程\1.basic\.images\docker_run3.jpg)





### Linux-Cgroups资源隔离

Cgroups是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制。

![docker_groups](H:\文章\K8S基础教程\1.basic\.images\docker_groups.jpg)

Linux-Cgroups功能

Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。
Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。
Accounting: 一些审计或一些统计，主要目的是为了计费。
Control: 挂起进程，恢复执行进程。

Docker 限制容器能够使用的资源量参数：
-m 4G --memory-swap 0 --cpu-period=1000000 --cpu-quota=8000000 



### 资源隔离和共享

本小节简单地讲解 Docker 的实现原理，读者可以从中了解 Linux 是如何隔离资源的、Docker 又是如何隔离的。



我们知道，操作系统是以一个进程为单位进行资源调度的，现代操作系统为进程设置了资源边界，每个进程使用自己的内存区域等，进程之间不会出现内存混用。Linux 内核中，有 cgroups 和 namespaces 可以为进程定义边界，使得进程彼此隔离。

本小节中将讲解一些容器环境隔离以及资源共享的相关知识。

Docker 依赖 Linux 内核的 namespace 、cgroup 等实现的。

#### namespace

在容器中，当我们使用 top 命令或 ps 命令查看机器的进程时，可以看到进程的 Pid，每个进程都有一个 Pid，而机器的所有容器都具有一个 Pid = 1 的基础，但是为什么不会发生冲突？容器中的进程可以任意使用所有端口，而不同容器可以使用相同的端口，为什么不会发生冲突？这些都是资源可以设定边界的表现。

在 Linux 中，namespace 是一种资源隔离方案，可以将系统中的网络、进程环境等进行隔离，使得每个 namespace 中的系统资源不再是全局性的。



**namespace 主要是一种环境隔离机制**。



Linux 中，unshare 可以创建一个命名空间，并且创建一些资源。实际上这个命名空间是一个进程，命名空间中的其它进程是这个进程的子进程。为了深刻理解 Linux 中的 namespace，我们可以在 Linux 中执行：

```shell
unshare --pid /bin/sh  
```

此时我们进入了一个新的隔离的命名空间，执行 top 命令查看进程列表。

```
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND               
    1 root      20   0  160188   8276   5488 S   0.0  0.4   9:35.58 systemd               
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.08 kthreadd             
    3 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 rcu_gp               
    4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 rcu_par_gp          
```

> 我们还可以使用 nsenter 命令进入另一个命名空间。



上面查询到的结果是不是跟 Docker 容器执行命令的结果相似？

上面的命令中，`--pid` 参数创建 隔离进程的命名空间，此外，还可以隔离多种系统资源：

* mount ：命名空间具有独立的挂载文件系统；
* ipc：Inter-Process Communication (进程间通讯)命名空间，具有独立的信号量、共享内存等；
* uts：命名空间具有独立的 hostname 、domainname；
* net：独立的网络，例如每个 docker 容器都有一个虚拟网卡；
* pid：独立的进程空间，空间中的进程 Pid 都从 1 开始；
* user：命名空间中有独立的用户体系，例如 Docker 中的 root 跟主机的用户不一样；
* cgroup：独立的用户分组；

再这个命令中，只隔离了进程，因为并没有隔离网络，因此当我们执行 `netstat --tlap` 命令时，这个命名空间的网络跟其它命名空间的网络是一样的。



#### cgroups

cgroups 全称是 Control Groups，cgroups 可以限制进程可使用的内存、CPU、网络 IO，**是 Linux 内核中的物理资源隔离机制**。

cgroups 可以控制多种资源，在 cgroups 中每种资源对于一个子系统，可以使用命令查看：

```shell
mount | grep cgroup
```

![cgroups](H:\文章\K8S基础教程\1.basic\.images\cgroups.png)

>每种子系统的功能概要如下：
>
>- `blkio` — 该子系统对进出块设备的输入/输出访问设置限制，如 USB 等。
>- `cpu` — 该子系统使用调度程序来提供对 CPU 的 cgroup 任务访问。
>- `cpuacct` — 该子系统生成有关 cgroup 中任务使用的 CPU 资源的自动报告。
>- `cpuset` — 该子系统将单个 CPU和内存节点分配给 cgroup 中的任务。
>- `devices` — 该子系统允许或拒绝 cgroup 中的任务访问设备。
>- `freezer` — 该子系统在 cgroup 中挂起或恢复任务。
>- `memory` — 该子系统对 cgroup 中的任务使用的内存设置限制，并生成有关自动报告。
>- `net_cls`— 允许 Linux 流量控制器 ( `tc`) 识别源自特定 cgroup 任务的数据包。
>- `net_prio` — 该子系统提供了一种动态设置每个网络接口的网络流量优先级的方法。
>- `ns`—*命名空间*子系统。
>- `perf_event` — 该子系统识别任务的 cgroup 成员资格，可用于性能分析。
>
>请参考：[redhat 文档](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch01)



为了避免篇幅过大，读者只需要知道 Docker 限制容器资源使用量、CPU 核数等操作，其原理是 Linux 内核中的 cgroups 即可，笔者这里不再赘述。





## Go 简单实现 进程隔离

