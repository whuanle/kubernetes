# 2.应用部署、网络和副本集





## ReplicaSet

ReplicaSet 为副本集的意思，Delpoyment 部署的 Pod，可以指定其副本数量，副本数量就是表示部署多少个 Pod。

我们执行 `kubectl get deployments` 命令，输出：

```text
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   1/1     1            1           38m
```

* `NAME` 列出了集群中 Deployment 的名称。
* `READY` 显示应用程序的可用的 _副本_ 数。显示的模式是“就绪个数/期望个数”。
* `UP-TO-DATE` 显示为了达到期望状态已经更新的副本数。
* `AVAILABLE` 显示应用可供用户使用的副本数。
* `AGE` 显示应用程序运行的时间。

### 扩容 Pod

因为容器化应用中，根据云原生12因素的方法论和核心思想，一个 `Processes` 应当是无状态的，任何持久化的数据都要存储在后端服务中。因此，A 镜像，启动 N 个 docker 容器，端口为 801、802、803...，他们其实都是一样的，我们访问哪个容器，最终提供的服务都是一致的。

但是，如果我们把这些容器放到不同 Node 中，再通过 k8s ，就可以为多个实例之间分配流量，即负载均衡。

在 Deployment 中，可以通过指定 yaml 文件的 `.spec.replicas` 字段或者以命令参数 `--replicas=` 设置副本数量。

我们可以动态修改 YAML 文件：

```text
kubectl edit deployment nginx
```

在 `spec` 字段后面找到 `replicas: 1`，修改为 `replicas: 2`。

!\[1620052411\(1\)\]\(./.images/1620052411\(1\).png\)

再次查看 deployment：

```text
root@instance-1:~# kubectl get deployments
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   2/2     2            2           24m
```

前面，已经通过修改 Deployment 对象的 YAML 文件实现多副本\(扩容，这里学习一下 `kubectl scale` 扩容命令，更加方便。

```text
kubectl scale deployment nginx --replicas=3
```

然后等几秒后执行 `kubectl get deployments` 查看结果。

```text
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
nginx   3/3     3            3           3h15m
```

执行 `kubectl get pod -o wide` 可以输出信息的 pod 信息 。

```text
NAME       READY   STATUS   ESTARTS   AGE     IP              NODE     NOMINATED NODE   READINESS GATES
nginx-581   1/1     Running   0     3h11m   192.168.56.24   instance-2   <none>           <none>
nginx-582   1/1     Running   0     3m30s   192.168.56.25   instance-2   <none>           <none>
nginx-583   1/1     Running   0     3m30s   192.168.56.26   instance-2   <none>           <none>
# 注，笔者删除了Name的部分名称
```

当我们使用 `kubectl delete xxx` 删除 pod 时，Deployment 会自动保持三个副本集，会自动启用新的 pod ，你可以删除其中一个或多个 Pod，再查看 Pod 数量，会发现一直保持 3 个。

## 考点

需要学会增删查改 Deployment、Pod，了解如何访问 Pod，如何创建一个 Service、扩容 Pod\(副本集\)。

